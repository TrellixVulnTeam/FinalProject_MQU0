{"version":3,"file":"dynamic-overlay.d.ts","sources":["dynamic-overlay.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ComponentFactoryResolver, ComponentRef, NgZone, Type } from '@angular/core';\r\nimport { Subject, BehaviorSubject, Observable } from 'rxjs';\r\nimport { NbAdjustableConnectedPositionStrategy, NbPosition } from '../overlay-position';\r\nimport { NbRenderableContainer } from '../overlay-container';\r\nimport { NbOverlayContent, NbOverlayService } from '../overlay-service';\r\nimport { NbOverlayRef, NbOverlayContainer, NbOverlayConfig } from '../mapping';\r\nexport interface NbDynamicOverlayController {\r\n    show(): any;\r\n    hide(): any;\r\n    toggle(): any;\r\n    rebuild(): any;\r\n}\r\nexport declare class NbDynamicOverlay {\r\n    protected overlay: NbOverlayService;\r\n    protected componentFactoryResolver: ComponentFactoryResolver;\r\n    protected zone: NgZone;\r\n    protected overlayContainer: NbOverlayContainer;\r\n    protected ref: NbOverlayRef;\r\n    protected container: ComponentRef<NbRenderableContainer>;\r\n    protected componentType: Type<NbRenderableContainer>;\r\n    protected context: Object;\r\n    protected content: NbOverlayContent;\r\n    protected positionStrategy: NbAdjustableConnectedPositionStrategy;\r\n    protected overlayConfig: NbOverlayConfig;\r\n    protected lastAppliedPosition: NbPosition;\r\n    protected positionStrategyChange$: Subject<unknown>;\r\n    protected isShown$: BehaviorSubject<boolean>;\r\n    protected destroy$: Subject<void>;\r\n    protected overlayDestroy$: Subject<import(\"@angular/cdk/overlay\").OverlayRef>;\r\n    get isAttached(): boolean;\r\n    get isShown(): Observable<boolean>;\r\n    constructor(overlay: NbOverlayService, componentFactoryResolver: ComponentFactoryResolver, zone: NgZone, overlayContainer: NbOverlayContainer);\r\n    create(componentType: Type<NbRenderableContainer>, content: NbOverlayContent, context: Object, positionStrategy: NbAdjustableConnectedPositionStrategy, overlayConfig?: NbOverlayConfig): this;\r\n    setContent(content: NbOverlayContent): void;\r\n    setContext(context: Object): void;\r\n    setContentAndContext(content: NbOverlayContent, context: Object): void;\r\n    setComponent(componentType: Type<NbRenderableContainer>): void;\r\n    setPositionStrategy(positionStrategy: NbAdjustableConnectedPositionStrategy): void;\r\n    setOverlayConfig(overlayConfig: NbOverlayConfig): void;\r\n    show(): any;\r\n    hide(): void;\r\n    toggle(): void;\r\n    dispose(): void;\r\n    getContainer(): ComponentRef<NbRenderableContainer>;\r\n    protected createOverlay(): void;\r\n    protected renderContainer(): void;\r\n    protected updateContext(): void;\r\n    protected createContainerContext(): Object;\r\n    /**\r\n     * Dimensions of the container may change after content update. So we listen to zone.stable event to\r\n     * reposition the container.\r\n     */\r\n    protected updatePositionWhenStable(overlay: NbOverlayRef): void;\r\n    protected updatePosition(): void;\r\n    protected hasOverlayInContainer(): boolean;\r\n    protected disposeOverlayRef(): void;\r\n}\r\n"]}