import { Component, Input, ViewEncapsulation, ChangeDetectionStrategy, } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class NgxProgressCircleComponent {
    constructor() {
        this.value = 0;
        this.symbol = '%';
        this.label = 'complete';
        this.valueLabel = '';
        this.radius = 74;
        this.circumference = 2 * Math.PI * this.radius;
        this.dashoffset = 0;
        this.progress(0);
    }
    ngOnChanges(changes) {
        this.progress(changes.value.currentValue);
    }
    progress(value) {
        const progress = value / 100;
        this.dashoffset = this.circumference * (1 - progress);
    }
}
NgxProgressCircleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxProgressCircleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NgxProgressCircleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.2", type: NgxProgressCircleComponent, selector: "ngx-progress-circle", inputs: { value: "value", symbol: "symbol", label: "label", valueLabel: "valueLabel" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"ngx-progress-circle\">\n  <svg class=\"ngx-progress-circle__svg\" width=\"170\" height=\"170\" viewBox=\"0 0 170 170\">\n    <circle class=\"ngx-progress-circle__svg__meter\" cx=\"84\" cy=\"84\" [attr.r]=\"radius\" stroke-width=\"16\" />\n    <circle class=\"ngx-progress-circle__svg__value\" [style.strokeDasharray]=\"circumference\" [style.strokeDashoffset]=\"dashoffset\"\n      cx=\"84\" cy=\"84\" [attr.r]=\"radius\" stroke-width=\"16\" />\n  </svg>\n\n  <div class=\"ngx-progress-circle__value\">\n    <ng-container *ngIf=\"valueLabel !== null\">{{valueLabel}}</ng-container>\n    <ng-container *ngIf=\"valueLabel === null\">{{value}}</ng-container>{{symbol}}\n  </div>\n\n  <div *ngIf=\"!valueLabel\" class=\"ngx-progress-circle__value ng-content\">\n    <ng-content select=\"[icon-value-label]\"></ng-content>\n  </div>\n\n  <div class=\"ngx-progress-circle__complete\">{{label}}</div>\n</div>\n", styles: ["*,:after,:before{box-sizing:border-box}ngx-progress-circle{display:inline-block;--color-stroke:#3d3d3d;--color-circle:#f2f2f2}.ngx-progress-circle{position:relative;width:170px;height:170px;margin:0 auto}.ngx-progress-circle__svg{transform:rotate(-90deg)}.ngx-progress-circle__svg__meter,.ngx-progress-circle__svg__value{fill:none}.ngx-progress-circle__svg__meter{stroke:#f2f2f2;stroke:var(--color-circle)}.ngx-progress-circle__svg__value{stroke:#3d3d3d;stroke:var(--color-stroke);stroke-linecap:round;transition:all}.ngx-progress-circle__value{position:absolute;top:62px;text-align:center;font-size:2.7em;width:100%}.ngx-progress-circle__value.ng-content{top:50px}.ngx-progress-circle__complete{font-size:1.1em;position:absolute;text-align:center;width:100%;top:96px}"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.2", ngImport: i0, type: NgxProgressCircleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngx-progress-circle',
                    templateUrl: './ngx-progress-circle.component.html',
                    styleUrls: ['./ngx-progress-circle.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { value: [{
                type: Input
            }], symbol: [{
                type: Input
            }], label: [{
                type: Input
            }], valueLabel: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzLWNpcmNsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHJvZ3Jlc3Mvc3JjL25neC1wcm9ncmVzcy1jaXJjbGUvbmd4LXByb2dyZXNzLWNpcmNsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHJvZ3Jlc3Mvc3JjL25neC1wcm9ncmVzcy1jaXJjbGUvbmd4LXByb2dyZXNzLWNpcmNsZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFHTCxpQkFBaUIsRUFDakIsdUJBQXVCLEdBQ3hCLE1BQU0sZUFBZSxDQUFDOzs7QUFTdkIsTUFBTSxPQUFPLDBCQUEwQjtJQVVyQztRQVRTLFVBQUssR0FBa0IsQ0FBQyxDQUFDO1FBQ3pCLFdBQU0sR0FBRyxHQUFHLENBQUM7UUFDYixVQUFLLEdBQUcsVUFBVSxDQUFDO1FBQ25CLGVBQVUsR0FBRyxFQUFFLENBQUM7UUFFekIsV0FBTSxHQUFHLEVBQUUsQ0FBQztRQUNaLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMxQyxlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBR2IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU8sUUFBUSxDQUFDLEtBQWE7UUFDNUIsTUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUM7SUFDeEQsQ0FBQzs7dUhBckJVLDBCQUEwQjsyR0FBMUIsMEJBQTBCLHdLQ2hCdkMsczVCQWtCQTsyRkRGYSwwQkFBMEI7a0JBUHRDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjtvQkFDL0IsV0FBVyxFQUFFLHNDQUFzQztvQkFDbkQsU0FBUyxFQUFFLENBQUMsc0NBQXNDLENBQUM7b0JBQ25ELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO29CQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQ7MEVBRVUsS0FBSztzQkFBYixLQUFLO2dCQUNHLE1BQU07c0JBQWQsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csVUFBVTtzQkFBbEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE9uQ2hhbmdlcyxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LXByb2dyZXNzLWNpcmNsZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9uZ3gtcHJvZ3Jlc3MtY2lyY2xlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbmd4LXByb2dyZXNzLWNpcmNsZS5jb21wb25lbnQuc2NzcyddLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTmd4UHJvZ3Jlc3NDaXJjbGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB2YWx1ZTogbnVtYmVyIHwgbnVsbCA9IDA7XG4gIEBJbnB1dCgpIHN5bWJvbCA9ICclJztcbiAgQElucHV0KCkgbGFiZWwgPSAnY29tcGxldGUnO1xuICBASW5wdXQoKSB2YWx1ZUxhYmVsID0gJyc7XG5cbiAgcmFkaXVzID0gNzQ7XG4gIGNpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMucmFkaXVzO1xuICBkYXNob2Zmc2V0ID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb2dyZXNzKDApO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIHRoaXMucHJvZ3Jlc3MoY2hhbmdlcy52YWx1ZS5jdXJyZW50VmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9ncmVzcyh2YWx1ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSB2YWx1ZSAvIDEwMDtcbiAgICB0aGlzLmRhc2hvZmZzZXQgPSB0aGlzLmNpcmN1bWZlcmVuY2UgKiAoMSAtIHByb2dyZXNzKTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cIm5neC1wcm9ncmVzcy1jaXJjbGVcIj5cbiAgPHN2ZyBjbGFzcz1cIm5neC1wcm9ncmVzcy1jaXJjbGVfX3N2Z1wiIHdpZHRoPVwiMTcwXCIgaGVpZ2h0PVwiMTcwXCIgdmlld0JveD1cIjAgMCAxNzAgMTcwXCI+XG4gICAgPGNpcmNsZSBjbGFzcz1cIm5neC1wcm9ncmVzcy1jaXJjbGVfX3N2Z19fbWV0ZXJcIiBjeD1cIjg0XCIgY3k9XCI4NFwiIFthdHRyLnJdPVwicmFkaXVzXCIgc3Ryb2tlLXdpZHRoPVwiMTZcIiAvPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJuZ3gtcHJvZ3Jlc3MtY2lyY2xlX19zdmdfX3ZhbHVlXCIgW3N0eWxlLnN0cm9rZURhc2hhcnJheV09XCJjaXJjdW1mZXJlbmNlXCIgW3N0eWxlLnN0cm9rZURhc2hvZmZzZXRdPVwiZGFzaG9mZnNldFwiXG4gICAgICBjeD1cIjg0XCIgY3k9XCI4NFwiIFthdHRyLnJdPVwicmFkaXVzXCIgc3Ryb2tlLXdpZHRoPVwiMTZcIiAvPlxuICA8L3N2Zz5cblxuICA8ZGl2IGNsYXNzPVwibmd4LXByb2dyZXNzLWNpcmNsZV9fdmFsdWVcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidmFsdWVMYWJlbCAhPT0gbnVsbFwiPnt7dmFsdWVMYWJlbH19PC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInZhbHVlTGFiZWwgPT09IG51bGxcIj57e3ZhbHVlfX08L25nLWNvbnRhaW5lcj57e3N5bWJvbH19XG4gIDwvZGl2PlxuXG4gIDxkaXYgKm5nSWY9XCIhdmFsdWVMYWJlbFwiIGNsYXNzPVwibmd4LXByb2dyZXNzLWNpcmNsZV9fdmFsdWUgbmctY29udGVudFwiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltpY29uLXZhbHVlLWxhYmVsXVwiPjwvbmctY29udGVudD5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cIm5neC1wcm9ncmVzcy1jaXJjbGVfX2NvbXBsZXRlXCI+e3tsYWJlbH19PC9kaXY+XG48L2Rpdj5cbiJdfQ==