'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var isValidChecksumAddress = require('ethereumjs-util').isValidChecksumAddress;
var BN = require('bn.js');
var assert = require('chai').assert;
var wallet = require('demo-keys').wallet;
var isDeploy = require('demo-contract').isDeploy;
var Imm = __importStar(require("immutable"));
exports.makeCheckerFromBoolean = function (booleanChecker, typeName) {
    return function (arg) {
        var argString = ((typeof (arg) === 'object') && (!Array.isArray(arg)) && (arg !== null)) ?
            "object with keys " + JSON.stringify(Imm.List(Imm.Map(arg).keys()).toJS()) :
            JSON.stringify(arg);
        return booleanChecker(arg) ?
            {} : { error: "Arg " + argString + " did not have type " + typeName };
    };
};
exports.makeRequired = function (checkerFunc, typeName) {
    var callable = function (arg) { return checkerFunc(arg); };
    callable.typeName = typeName;
    return callable;
};
exports.makeOptional = function (checkerFunc, typeName) {
    var callable = function (arg) { return (arg === undefined) ? {} : checkerFunc(arg); };
    callable.typeName = typeName + '?';
    return callable;
};
exports.makeMapType = function (mapType, typeName) {
    var checkerFunc = function (arg) {
        if (!Imm.Map.isMap(arg)) {
            return { error: "Passed in a non-map arg to a map type " + typeName };
        }
        var errorString = mapType.reduce(function (s, subArgChecker, subArgName) {
            var subArg = arg.get(subArgName);
            var subSatisfied = subArgChecker(subArg);
            if (!subSatisfied) {
                return "Arg checker " + subArgChecker + " for sub arg " + subArgName + " returns null result";
            }
            if (subSatisfied['error']) {
                return "Map-type sub-arg \"" + subArgName + ": " + subArg + "\" does not have type " + subArgChecker.typeName + " instead " + typeof (subArg) + ". " + subSatisfied['error'];
            }
            return s + (subSatisfied['error'] || '');
        }, '');
        return { error: errorString };
    };
    var newType = exports.makeRequired(checkerFunc, typeName);
    newType.opt = exports.makeOptional(checkerFunc, typeName);
    newType.childTypes = mapType;
    return newType;
};
var HEX_CHARS = '01234567890abcdef';
exports.isHexPrefixed = function (arg, length, prefixed) {
    if (prefixed === void 0) { prefixed = true; }
    var allHexChars = function (s, v, k) {
        return (HEX_CHARS.search(v.toLowerCase()) > -1) ? s :
            { error: "Non-hex char " + v + " found at position " + k };
    };
    if (typeof (arg) !== 'string') {
        return { error: arg + " has type " + typeof (arg) + " instead of string" };
    }
    if (Boolean(prefixed) === true && arg.slice(0, 2) !== '0x') {
        return { error: arg + " does not begin with 0x" };
    }
    if (length && arg.length !== length) {
        return { error: arg + " has length " + arg.length + " instead of " + length };
    }
    return Imm.List(arg.slice(2)).reduce(allHexChars, {});
};
var contractCheckerFunc = function (arg) {
    return Boolean(arg && isDeploy(arg.deploy) && arg.deployerEth['prepareSignerEth']);
};
var contractInstanceCheckerFunc = function (arg) {
    return Boolean(arg && arg['abi'] && isValidChecksumAddress(arg['address']));
};
// Standard arg types / checkers
var BOOLEAN_CHECKERS = Imm.Map({
    'string': function (arg) { return (typeof (arg) === 'string'); },
    'number': function (arg) { return (typeof (arg) === 'number'); },
    'boolean': function (arg) { return (typeof (arg) === 'boolean'); },
    'map': function (arg) { return (Imm.Map.isMap(arg)); },
    'list': function (arg) { return (Imm.List.isList(arg)); },
    'badType': function (arg) { return false; },
    'any': function (arg) { return true; },
    'integer': function (arg) { return Number.isInteger(arg); },
    'floatString': function (arg) { return ((typeof (arg) === 'string') && (String(parseFloat(arg)) === arg)); },
    'float': function (arg) { return typeof (parseFloat(arg)) === 'number'; },
    'function': function (arg) { return (typeof (arg) === 'function'); },
    'ethereumAddress': function (arg) { return isValidChecksumAddress(arg); },
    'ethereumSigner': function (arg) { return Boolean(arg && arg['net_version']); },
    'contract': contractCheckerFunc,
    'contractInstance': contractInstanceCheckerFunc,
    'bm': function (arg) { return Boolean(arg && arg['getDeploys']); },
    'wallet': function (arg) { return Boolean(arg && arg['prepareSignerEth']); },
    'array': function (arg) { return Array.isArray(arg); },
    'bn': function (arg) { return BN.isBN(arg); },
});
/**
 * Create a checker function (that returns a [[Result]]) with an optional
 * type (called `opt`) from a
 * boolean checker function (that returns `true` if the typecheck passes and
 * `false` otherwise.
 * @param booleanChecker the boolean checker function to convert
 * @param typeName a short descriptive name for this type
 */
exports.makeCheckerFuncFromBoolean = function (booleanChecker, typeName) {
    var checker = exports.makeCheckerFromBoolean(booleanChecker, typeName);
    var requiredChecker = exports.makeRequired(checker, typeName);
    requiredChecker.opt = exports.makeOptional(checker, typeName);
    return requiredChecker;
};
exports.makeCheckerFunc = function (checker, typeName) {
    var requiredChecker = exports.makeRequired(checker, typeName);
    requiredChecker.opt = exports.makeOptional(checker, typeName);
    return requiredChecker;
};
exports.TYPES_MAP = BOOLEAN_CHECKERS.map(exports.makeCheckerFuncFromBoolean).
    merge({
    'hexPrefixed': exports.makeCheckerFunc(function (arg) { return exports.isHexPrefixed(arg); }, 'hexPrefixed'),
    'keccak256Prefixed': exports.makeCheckerFunc(function (arg) { return exports.isHexPrefixed(arg, 66, true); }, 'keccak256Hash'),
    'keccak256Hash': exports.makeCheckerFunc(function (arg) { return exports.isHexPrefixed(arg, 64, false); }, 'keccak256Hash'),
    'ethereumTxHash': exports.makeCheckerFunc(function (arg) { return exports.isHexPrefixed(arg, 66, true); }, 'ethereumTxHash'),
});
exports.TYPES = exports.TYPES_MAP.toJSON();
exports.checkExtractArgs = function (args, argTypes) {
    return argTypes.map(function (argType, argName) {
        var argCheckers = Imm.List([argType]);
        var arg = args.get(argName); // could be undefined
        var errorString = argCheckers.reduce(function (errorString, checker, i, checkers) {
            return errorString + (checker(arg)['error'] || '');
        }, '');
        assert.equal(errorString, '', "Arg named " + argName + " mismatched type " + argType.typeName + " " +
            ("with error string " + errorString));
        return arg;
    });
};
